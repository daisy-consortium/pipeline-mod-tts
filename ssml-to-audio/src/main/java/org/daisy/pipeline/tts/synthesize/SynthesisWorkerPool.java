package org.daisy.pipeline.tts.synthesize;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;

import net.sf.saxon.s9api.QName;
import net.sf.saxon.s9api.XdmNode;

import org.daisy.pipeline.audio.AudioEncoder;
import org.daisy.pipeline.tts.TTSRegistry;
import org.daisy.pipeline.tts.TTSRegistry.TTSResource;
import org.daisy.pipeline.tts.TTSService;
import org.daisy.pipeline.tts.TTSService.SynthesisException;
import org.daisy.pipeline.tts.TTSServiceUtil;
import org.daisy.pipeline.tts.Voice;

public class SynthesisWorkerPool implements IProgressListener {
	static class Speakable {
		Speakable(Voice voice, XdmNode sentence) {
			this.voice = voice;
			this.sentence = sentence;
		}

		public int computeSize() {
			//TODO: write finer/faster computation
			return sentence.toString().length();
		}

		Voice voice;
		XdmNode sentence;
	}

	public static class UndispatchableSection implements Comparable<UndispatchableSection>,
	        Cloneable {
		int size;
		int documentPosition;
		int documentSubPosition;
		File audioOutputDir;
		List<Speakable> speakables;
		TTSService synthesizer;
		Voice voice;

		void computeSize() {
			size = 0;
			for (Speakable speakable : speakables) {
				size += speakable.computeSize();
			}
		}

		@Override
		public int compareTo(UndispatchableSection other) {
			return (other.size - size);
		}

		@Override
		protected Object clone() {
			UndispatchableSection cl = new UndispatchableSection();
			cl.size = size;
			cl.documentPosition = documentPosition;
			cl.documentSubPosition = documentSubPosition;
			cl.audioOutputDir = audioOutputDir;
			cl.speakables = speakables;
			cl.synthesizer = synthesizer;
			cl.voice = voice;
			return cl;
		}
	}

	private SynthesisWorkerThread[] mWorkers;
	private TTSService currentSynthesizer;
	private AudioEncoder mEncoder;
	private TTSRegistry mTTSRegistry;
	private IPipelineLogger mLogger;
	private List<UndispatchableSection> mSections;
	private UndispatchableSection mCurrentSection;
	private Voice mPreviousVoice;
	private int mNrThreads;
	private File mAudioDir;
	private long mTotalTextSize;
	private long mPrintedProgress;
	private long mProgress;

	public SynthesisWorkerPool(int threadNumber, TTSRegistry registry, AudioEncoder encoder,
	        IPipelineLogger logger) {
		mNrThreads = threadNumber;
		mWorkers = new SynthesisWorkerThread[threadNumber];
		for (--threadNumber; threadNumber >= 0; --threadNumber)
			mWorkers[threadNumber] = new SynthesisWorkerThread();

		mTTSRegistry = registry;
		mEncoder = encoder;
		mLogger = logger;
	}

	public void initialize(File audioDir) {
		mSections = new ArrayList<UndispatchableSection>();
		mCurrentSection = null;
		mPreviousVoice = null;
		mAudioDir = audioDir;
	}

	/**
	 * The SSML is assumed to be pushed in document order.
	 * */
	public void pushSSML(XdmNode ssml) throws SynthesisException {
		String voiceVendor = ssml.getAttributeValue(new QName("voice-selector1"));
		String voiceName = ssml.getAttributeValue(new QName("voice-selector2"));
		String lang = ssml.getAttributeValue(new QName("http://www.w3.org/XML/1998/namespace",
		        "lang"));

		Voice voice = mTTSRegistry.findAvailableVoice(voiceVendor, voiceName, lang);
		if (voice == null) {
			mLogger.printInfo("Could not find any installed voice matching "
			        + new Voice(voiceVendor, voiceName) + " or providing the language '"
			        + lang + "'");
			if (mPreviousVoice == null) {
				mLogger.printInfo("The corresponding part of the text won't be synthesized.");
				endSection();
				return;
			} else {
				voice = mPreviousVoice;
				mLogger.printInfo("Voice " + voice + " will be used instead.");
			}
		} else
			mPreviousVoice = voice;

		TTSService newSynth = mTTSRegistry.getTTS(voice);
		if (newSynth == null) {
			// Should not happen, since findAvailableVoice() returns only a non-null voice if it is available.
			mLogger.printInfo("Could find any TTS processor for the voice " + voice);
			return;
		}
		if (newSynth != currentSynthesizer) {
			if (currentSynthesizer != null
			        && !currentSynthesizer.getAudioOutputFormat().equals(
			                newSynth.getAudioOutputFormat()))
				endSection(); // the same thread won't be able to
				              // concatenate outputs generated by different TTS
			currentSynthesizer = newSynth;
		}

		if (mCurrentSection == null) {
			mCurrentSection = new UndispatchableSection();
			mSections.add(mCurrentSection);
			mCurrentSection.speakables = new ArrayList<Speakable>();
			mCurrentSection.synthesizer = currentSynthesizer;
			mCurrentSection.documentPosition = mSections.size();
			mCurrentSection.audioOutputDir = mAudioDir;
		}
		mCurrentSection.speakables.add(new Speakable(voice, ssml));
	}

	public void endSection() {
		mCurrentSection = null;
	}

	public void splitSection(UndispatchableSection section, int maxSize,
	        List<UndispatchableSection> newSections) {
		int left = 0;
		int count = 0;
		UndispatchableSection currentSection = (UndispatchableSection) section.clone();
		currentSection.size = 0;
		for (int right = 0; right < section.speakables.size(); ++right) {
			if (currentSection.size > maxSize) {
				currentSection.speakables = section.speakables.subList(left, right);
				currentSection.documentSubPosition = count;
				newSections.add(currentSection);
				currentSection = (UndispatchableSection) section.clone();
				currentSection.size = 0;
				left = right;
				++count;
			}
			currentSection.size += section.speakables.get(right).computeSize();
		}
		currentSection.speakables = section.speakables
		        .subList(left, section.speakables.size());
		currentSection.documentSubPosition = count;
		newSections.add(currentSection);
	}

	public void synthesizeAndWait(List<SoundFragment> soundfragments)
	        throws SynthesisException {
		//compute the sections' size: needed for displaying the progress,
		//splitting the sections and sorting the sections
		for (UndispatchableSection section : mSections)
			section.computeSize();
		mTotalTextSize = 0;
		for (UndispatchableSection section : mSections) {
			mTotalTextSize += section.size;
		}
		mProgress = 0;
		mPrintedProgress = 0;

		//split the section which are too big
		int maxSize = (int) (mTotalTextSize / 15);
		List<UndispatchableSection> newSections = new ArrayList<UndispatchableSection>();
		List<UndispatchableSection> toRemove = new ArrayList<UndispatchableSection>();
		for (UndispatchableSection section : mSections) {
			if (section.size >= maxSize) {
				toRemove.add(section);
				splitSection(section, maxSize, newSections);
			}
		}

		mSections.removeAll(toRemove);
		mSections.addAll(newSections);

		//sort the 'undispatchable' sections according to their size in descending-order
		Collections.sort(mSections);
		mLogger.printInfo("number of sections to synthesize: " + mSections.size());

		//give SynthetisWorkerThread access to a synchronized queue of sections to synthesize
		ConcurrentLinkedQueue<UndispatchableSection> queue = new ConcurrentLinkedQueue<UndispatchableSection>(
		        mSections);
		for (SynthesisWorkerThread worker : mWorkers)
			worker.init(mEncoder, mLogger, this, soundfragments, queue);

		//pre-allocate resources for every TTS of every thread
		Set<TTSService> allTTS = new HashSet<TTSService>();
		for (UndispatchableSection section : mSections)
			allTTS.add(section.synthesizer);

		StringBuilder sb = new StringBuilder("start allocating the resources on " + mNrThreads
		        + " threads for the following TTS service(s):");
		for (TTSService tts : allTTS) {
			sb.append("\n * " + TTSServiceUtil.displayName(tts));
		}
		mLogger.printInfo(sb.toString());

		for (TTSService tts : allTTS)
			for (SynthesisWorkerThread worker : mWorkers) {
				TTSResource resource = mTTSRegistry.allocateResourceFor(tts);
				worker.assignResource(tts, resource);
			}

		mLogger.printInfo("thread resources allocated.");

		//perform the synthesis and encoding
		for (SynthesisWorkerThread worker : mWorkers)
			worker.start();

		// wait for the threads to finish
		for (SynthesisWorkerThread worker : mWorkers)
			try {
				worker.join();
			} catch (InterruptedException e) {
				mLogger.printInfo("error while waiting for a thread to finish: "
				        + e.getMessage());
			}

		mLogger.printInfo("synthesis workers finished");

		if (queue.size() > 0) {
			mLogger.printInfo("warning: " + queue.size() + " sections not synthesized.");
		}
	}

	@Override
	synchronized public void notifyFinished(UndispatchableSection section) {
		mProgress += section.size;
		if (mProgress - mPrintedProgress > mTotalTextSize / 15) {
			mLogger.printInfo("progress: " + 100 * mProgress / mTotalTextSize + "%");
			mPrintedProgress = mProgress;
		}
	}
}
